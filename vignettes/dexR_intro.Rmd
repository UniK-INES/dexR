---
title: "Introduction to dexR"
author: "Sascha Holzhauer"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to dexR}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---


# Concept

The package provides various functions to run experiments, load data from db and XML configuration files, convert, and finally visualise it. Therefore, in a chain of production these functions need to be combined. At the same time, there are a number
of high level functions which integrate the more basic functions but leave less scope for customisation. These
high level functions start with 'hl'. 

## Parameters

There is a dexpa (DEX Parameters) list which contains all project-specific properties, directories, 
and  parameters. The basic idea is to define a dexpa list for each project and machine and execute the dexpa defining 
R code every time you start a script with the according project:

1. Before or within the script, the machine-specific DEXPA configuration (dexpa-maschine_XY.R) is loaded.

2. The machine-specific DEXPA includes the project-specific file (dexpaProject.R.).

```{r, eval=FALSE}
## DexpaProject.R
#### COMMON PACKAGES ###########################################################
library(shbasic)

#### FUNCTIONS #################################################################
#eg. for simp$dirs$param$getparamdir

### Simulation Data ############################################################
if (!exists("dexpa")) dexpa <-  dexR::param_getDefaultDexpa()

### DB Settings ##################################################################
if(!is.list(dexpa$db)) dexpa$db <- list()
dexpa$db$host			<- "localhost"
dexpa$db$port			<- "5432"
dexpa$db$dbname			<- "enavi"
dexpa$db$username		<- "enavi"
dexpa$db$password		<- "<password>"

dexpa$db$suname			<- "postgres"
dexpa$db$supassword		<- "<supassword>"
```

3. The project-specific file loads the default parameter list.

4. The script itself may then override particular parameter values with "local" properties 
(e.g. runID, image resolutions). Often it is a good idea to store setting/scenario specific values in a 
separate file (dexpa.R) within the setting/scenario R folder. 


The machine-specific dexpa part in an according script contains the (machine-specific) path 
to itself and to the machine-independent dexpa part script (dexpaProject.R), loads that general part and 
may overwrite certain parameters. The project dexpa file initially merges the defined parameters in the 
general dexR default parameter list to apply dexR defaults when no other specification is given.

Using the parameter set during an initial execution of the machine-dependent scripts at startup, each 
script using dexR should load the dexpa code anew. During that process, the entire dexpa list 
including all possible changes are removed from memory and loaded anew. Following above suggestions,
a script first loading the setting/scenario specific dexpa.R would look like this:

```{r, eval=FALSE}
# Only contained when the particular script is only executed on a specific machine!
# Otherwise. the machine-specific file needs to be executed before.
source("/PATH-TO/dexpa-machine_XY.R")

# dexpa$dirs$scripts is set by machine-specific file:
setwd(paste(dexpa$dirs$scripts, sep="/"))
# usually, the setting/scenario specific dexpa.R is a level above:
source("../dexpa.R")
```

The dexpa list consists of a number of sublists:

* sim

* dirs

* xml

* fig

* db

* colours

* debug
    
### Defining Colours

Colours for different purposes are defined in sublists of `dexpa$colours$products`, eg. `products` and `statuses`.

 
# Handling Data

## Database Management

Since DEX stores data to a PostGreSQL database, data of different runs should be stored in different databases. To this end, the main database DEX is writing to, needs to be either dumped to a files or duplicated to another database:

### Dump DB and restore to different DB

```{r, eval=FALSE}
dexR::input_db_db2dump(dexpa, dumpdir = paste("dump_", dexpa$sim$id, sep=""))
dp1 			<- dexpa
dp1$db$dbname 	<- "enavi_01-01"
dexR::input_db_dump2db(dp1, dumpfile=paste("dump_", dp1$sim$id, sep=""))
```

## Simulation Run IDs

Each simulation run should have a unique ID which is to be assigned to `dexpa$sim$id`.


## Comparing Runs/Scenarios

The generic way of comparing data of several simulation runs, i.e. combining the data to visualise in one plot, is the following:

1. For each data set to compare
	+ Store dumpfile into database
	+ Generate a dex-param-list for each run and store them in a list
2. Pass the list of dexpa objects to a comparison function

However, there a few high level functions that take a list of simp configurations and do not require the storage of combined data:

* hl_comp_aggregate_aftcompositions
* hl_comp_cell_aftcomposition


# Debugging/Logging

dexR uses the package 'futile.logger'. Initially, it sets up a console outputter 
to log everything on INFO level. However, the logger can be configured in a detailed way.

```{r, eval=FALSE}
futile.logger::flog.threshold(futile.logger::DEBUG, name='dexr')
futile.logger::flog.threshold(futile.logger::TRACE, name='dexr.input')
```
It is also possible to add handlers for further sinks.  

```{r, eval=FALSE}
futile.logger::flog.appender(appender.file(filename), name='dexr.output')
```

Compare the documentation for package 'futile.logger' for more detailed information.
A tutorial is also [available](http://www.r-bloggers.com/better-logging-in-r-aka-futile-logger-1-3-0-released/).


# Troubleshooting

## Error Messages
-
